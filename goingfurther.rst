Going Further With QORC SDK
===========================

With :code:`qorc-sdk v1.5.0+`, there are fundamental changes to the fpga toolchain, bootloader, and the flash programmer to support flexible, independent fpga use-cases.

.. contents::

Usage Scenarios
---------------

Standalone FPGA Usage
~~~~~~~~~~~~~~~~~~~~~

Previous to the v1.5.0 release, the method to use the FPGA always required usage of a M4 application to actually "wrap" the bistream (which is generated as a C Header), and program the FPGA.

TODO

Now, the FPGA design can be used with the new fpga toolchain (v1.3.1+) to produce a standalone binary.

This binary can then be flashed on the QuickFeather board and run, without needing any M4 application to "bootstrap" the FPGA.

TODO


Combined M4-FPGA Usage
~~~~~~~~~~~~~~~~~~~~~~

The most flexibility of the EOS S3 is the ability to have both M4 and FPGA working on independent things to achieve an end application scenario.

Previous to v1.5.0 release, it was always necessary that the M4 code "contain" the FPGA bitstream as well (Header Inclusion) - which also meant that the M4 Binary always included the entire FPGA image, which would be at least ~75kB.

TODO

This would not be a problem for smaller code on M4, but for more practical scenarios, this means we cannot use this memory for M4 code (out of a total of 512kB).

Now, with the generation(toolchain) and handling(programmer, bootloader) of separate FPGA binary, the M4 binary will not need to contain the FPGA bitstream, and so the entire memory (512kB) can be utilized.

TODO

Why Use "Header Inclusion" Method?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The "Header Inclusion" method has one advantage in development scenarios - as technically we use only M4 code in this approach, we can directly use a debugger to run and test the application, just like any normal Cortex-M4 application.

This does come with the limitation that the FPGA Generated Header takes up at least ~75kB out of the 512kB available for the M4 code.

Hence this method will be continued to be used and supported in the future as well.

If you have followed the :code:`quickstart.rst` guide, you have already come across 2 applications which both use this method :

- :code:`qf_helloworldhw` - uses a "blinky" FPGA design.

- :code:`qf_helloworldsw` - uses a "USB2SERIAL" FPGA design, which enables the EOSS3 to have a native USB-CDC port


FPGA Generated Header/Binary Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Detailed information on the internals of the binary (and other formats) generated by the fpga toolchain, are explained in TODO document.

This also explains the Bootloader process of loading the m4app, appfpga images.


Example Usage Methods
---------------------

This should give you an overview of the methods that can be used to create an application with standalone fpga designs as well as using fpga + m4 approach, which will open up the best parts of the EOSS3 to use.

Try A Standalone FPGA Test Application (qf_hellowordfpga)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO


Try An Integrated Application With FPGA Prebuilt (qf_helloworldsw_separate)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO


Try An Integrated Application With FPGA Build In Makefile (qf_advancedfpga_separate)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO
